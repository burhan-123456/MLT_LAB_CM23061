<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>MNIST CNN - TensorFlow.js</title>

  <!-- TensorFlow.js -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>

  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    pre { background: #f4f4f4; padding: 10px; }
  </style>
</head>

<body>

<h2>ðŸ§® MNIST Digit Recognition (CNN)</h2>
<p>Training for 5 epochs</p>

<pre id="log"></pre>

<script>
const log = document.getElementById("log");

/* -------- LOAD MNIST DATA MANUALLY -------- */
async function loadMNIST() {
  const imgRequest = await fetch(
    "https://storage.googleapis.com/learnjs-data/model-builder/mnist_images.png"
  );
  const labelRequest = await fetch(
    "https://storage.googleapis.com/learnjs-data/model-builder/mnist_labels_uint8"
  );

  const imgBlob = await imgRequest.blob();
  const imgBitmap = await createImageBitmap(imgBlob);

  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");

  const IMAGE_SIZE = 28 * 28;
  const NUM_IMAGES = 65000;

  canvas.width = imgBitmap.width;
  canvas.height = imgBitmap.height;
  ctx.drawImage(imgBitmap, 0, 0);

  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

  const images = new Float32Array(NUM_IMAGES * IMAGE_SIZE);
  for (let i = 0; i < NUM_IMAGES; i++) {
    const start = i * IMAGE_SIZE;
    for (let j = 0; j < IMAGE_SIZE; j++) {
      images[start + j] = imageData[start * 4 + j * 4] / 255;
    }
  }

  const labels = new Uint8Array(await labelRequest.arrayBuffer());

  return { images, labels };
}

/* -------- CREATE CNN MODEL -------- */
function createModel() {
  const model = tf.sequential();

  model.add(tf.layers.conv2d({
    inputShape: [28, 28, 1],
    filters: 16,
    kernelSize: 3,
    activation: "relu"
  }));

  model.add(tf.layers.maxPooling2d({ poolSize: 2 }));
  model.add(tf.layers.conv2d({ filters: 32, kernelSize: 3, activation: "relu" }));
  model.add(tf.layers.maxPooling2d({ poolSize: 2 }));
  model.add(tf.layers.flatten());

  model.add(tf.layers.dense({ units: 64, activation: "relu" }));
  model.add(tf.layers.dense({ units: 10, activation: "softmax" }));

  model.compile({
    optimizer: tf.train.adam(),
    loss: "categoricalCrossentropy",
    metrics: ["accuracy"]
  });

  return model;
}

/* -------- TRAIN MODEL -------- */
async function train() {
  log.innerText += "Loading MNIST data...\n";
  const { images, labels } = await loadMNIST();

  const TRAIN_SIZE = 5000;
  const TEST_SIZE = 1000;

  const xTrain = tf.tensor4d(images.slice(0, TRAIN_SIZE * 784),
    [TRAIN_SIZE, 28, 28, 1]);

  const yTrain = tf.oneHot(
    tf.tensor1d(labels.slice(0, TRAIN_SIZE), "int32"), 10
  );

  const xTest = tf.tensor4d(
    images.slice(TRAIN_SIZE * 784, (TRAIN_SIZE + TEST_SIZE) * 784),
    [TEST_SIZE, 28, 28, 1]
  );

  const yTest = tf.oneHot(
    tf.tensor1d(labels.slice(TRAIN_SIZE, TRAIN_SIZE + TEST_SIZE), "int32"), 10
  );

  const model = createModel();
  log.innerText += "Training started...\n";

  await model.fit(xTrain, yTrain, {
    epochs: 5,
    batchSize: 64,
    validationData: [xTest, yTest],
    callbacks: {
      onEpochEnd: (epoch, logs) => {
        log.innerText +=
          `Epoch ${epoch + 1}: accuracy = ${(logs.acc * 100).toFixed(2)}%\n`;
      }
    }
  });

  log.innerText += "\nâœ… Training completed\n";
}

train();
</script>

</body>
</html>

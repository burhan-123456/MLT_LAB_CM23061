<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>MNIST CNN Training + Canvas Prediction</title>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>

  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    pre { background: #f4f4f4; padding: 10px; }
    canvas { border: 2px solid black; cursor: crosshair; background: black; }
    button { margin-top: 10px; padding: 6px 12px; }
  </style>
</head>

<body>

<h2>üßÆ MNIST Digit Recognition (CNN)</h2>
<p>Training for 5 epochs</p>

<pre id="log"></pre>

<hr>

<h3>‚úçÔ∏è Draw a Digit (0‚Äì9)</h3>

<canvas id="drawCanvas" width="280" height="280"></canvas><br>
<button onclick="clearCanvas()">Clear</button>
<button onclick="predictDigit()">Predict Digit</button>

<h3 id="result">Prediction: ‚Äî</h3>

<script>
const log = document.getElementById("log");
let model;

/* ---------- LOAD MNIST ---------- */
async function loadMNIST() {
  const imgReq = await fetch(
    "https://storage.googleapis.com/learnjs-data/model-builder/mnist_images.png"
  );
  const lblReq = await fetch(
    "https://storage.googleapis.com/learnjs-data/model-builder/mnist_labels_uint8"
  );

  const imgBlob = await imgReq.blob();
  const bitmap = await createImageBitmap(imgBlob);

  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");

  const IMAGE_SIZE = 784;
  const NUM_IMAGES = 65000;

  canvas.width = bitmap.width;
  canvas.height = bitmap.height;
  ctx.drawImage(bitmap, 0, 0);

  const pixels = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
  const images = new Float32Array(NUM_IMAGES * IMAGE_SIZE);

  for (let i = 0; i < NUM_IMAGES; i++) {
    for (let j = 0; j < IMAGE_SIZE; j++) {
      images[i * IMAGE_SIZE + j] =
        pixels[i * IMAGE_SIZE * 4 + j * 4] / 255;
    }
  }

  const labels = new Uint8Array(await lblReq.arrayBuffer());
  return { images, labels };
}

/* ---------- CREATE CNN ---------- */
function createModel() {
  const model = tf.sequential();

  model.add(tf.layers.conv2d({
    inputShape: [28, 28, 1],
    filters: 16,
    kernelSize: 3,
    activation: 'relu'
  }));
  model.add(tf.layers.maxPooling2d({ poolSize: 2 }));
  model.add(tf.layers.flatten());
  model.add(tf.layers.dense({ units: 64, activation: 'relu' }));
  model.add(tf.layers.dense({ units: 10, activation: 'softmax' }));

  model.compile({
    optimizer: tf.train.adam(),
    loss: 'categoricalCrossentropy',
    metrics: ['accuracy']
  });

  return model;
}

/* ---------- TRAIN MODEL ---------- */
async function train() {
  log.innerText += "Loading MNIST data...\n";
  const { images, labels } = await loadMNIST();

  const TRAIN_SIZE = 5000;

  const xTrain = tf.tensor4d(
    images.slice(0, TRAIN_SIZE * 784),
    [TRAIN_SIZE, 28, 28, 1]
  );

  const yTrain = tf.oneHot(
    tf.tensor1d(labels.slice(0, TRAIN_SIZE), 'int32'), 10
  );

  model = createModel();
  log.innerText += "Training started...\n";

  await model.fit(xTrain, yTrain, {
    epochs: 5,
    batchSize: 64,
    callbacks: {
      onEpochEnd: (epoch, logs) => {
        log.innerText +=
          `Epoch ${epoch + 1}: accuracy = ${(logs.acc * 100).toFixed(2)}%\n`;
      }
    }
  });

  log.innerText += "\n‚úÖ Training completed. You can now draw digits.\n";

  xTrain.dispose();
  yTrain.dispose();
}

train();

/* ---------- CANVAS SETUP ---------- */
const canvas = document.getElementById("drawCanvas");
const ctx = canvas.getContext("2d");

ctx.fillStyle = "black";
ctx.fillRect(0, 0, canvas.width, canvas.height);

let drawing = false;
canvas.onmousedown = () => drawing = true;
canvas.onmouseup = () => drawing = false;
canvas.onmouseleave = () => drawing = false;

canvas.onmousemove = e => {
  if (!drawing) return;
  ctx.fillStyle = "white";
  ctx.beginPath();
  ctx.arc(e.offsetX, e.offsetY, 12, 0, Math.PI * 2);
  ctx.fill();
};

function clearCanvas() {
  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  document.getElementById("result").innerText = "Prediction: ‚Äî";
}

/* ---------- PREDICT ---------- */
function predictDigit() {
  if (!model) {
    alert("Model not trained yet!");
    return;
  }

  let tensor = tf.browser.fromPixels(canvas, 1)
    .resizeNearestNeighbor([28, 28])
    .toFloat()
    .div(255.0);

  // üî¥ INVERT COLORS (IMPORTANT)
  tensor = tf.sub(1.0, tensor);

  // üî¥ ADD BATCH DIMENSION
  tensor = tensor.reshape([1, 28, 28, 1]);

  const prediction = model.predict(tensor);
  const digit = prediction.argMax(1).dataSync()[0];

  document.getElementById("result").innerText =
    `Prediction: ${digit}`;

  tensor.dispose();
  prediction.dispose();
}

</script>

</body>
</html>
